- name: Retrieve, save, and email execution environment details
  hosts: localhost
  gather_facts: yes
  vars:
    awx_api_url: "http://192.168.4.100"
    awx_api_token: # Provide your AWX API token here
    execution_env_csv_file_path: "/home/automation/execution_environment_report.csv"
    gmail_user: "adebayobuss@gmail.com"
    gmail_pass: # Provide your Gmail App Password here
  tasks:
    - name: Ensure /home/automation directory exists
      ansible.builtin.file:
        path: /home/automation
        state: directory
        mode: '0755'

    - name: Fetch execution environments from AWX
      ansible.builtin.uri:
        url: "{{ awx_api_url }}/api/v2/execution_environments/"
        method: GET
        headers:
          Authorization: "Bearer {{ awx_api_token }}"
          Accept: "application/json"
        return_content: yes
        validate_certs: no
      register: execution_environments_response

    - name: Parse execution environment details
      ansible.builtin.set_fact:
        execution_environments_data: "{{ execution_environments_response.json.results }}"

    - name: Create empty CSV file for execution environments report
      ansible.builtin.file:
        path: "{{ execution_env_csv_file_path }}"
        state: touch

    - name: Create CSV file header for execution environments report
      ansible.builtin.copy:
        content: "Name,Collections,Python Libraries,Other Components,Inheritance\n"
        dest: "{{ execution_env_csv_file_path }}"
        force: yes

    - name: Fetch details for each execution environment
      ansible.builtin.uri:
        url: "{{ awx_api_url }}{{ item.url }}"
        method: GET
        headers:
          Authorization: "Bearer {{ awx_api_token }}"
          Accept: "application/json"
        return_content: yes
        validate_certs: no
      loop: "{{ execution_environments_data }}"
      register: execution_environment_details

    - name: Parse details for each execution environment
      ansible.builtin.set_fact:
        execution_environments_with_details: >
          {{
            execution_environment_details.results | map(attribute='json') | list
          }}

    - name: Append execution environment details to CSV
      ansible.builtin.lineinfile:
        path: "{{ execution_env_csv_file_path }}"
        line: >
          {{
            (item.name | default('N/A') | string) + "," +
            (item.collections | default('N/A') | string) + "," +
            (item.python_libraries | default('N/A') | string) + "," +
            (item.other_components | default('N/A') | string) + "," +
            (item.inheritance | default('N/A') | string)
          }}
        state: present
        create: yes
      loop: "{{ execution_environments_with_details }}"

    - name: Display content of the execution environments report CSV file
      ansible.builtin.shell: "cat {{ execution_env_csv_file_path }}"
      register: execution_env_csv_file_content

    - name: Show execution environments report CSV file content
      ansible.builtin.debug:
        msg: "{{ execution_env_csv_file_content.stdout }}"

    - name: Send email with the report using Python
      ansible.builtin.script: send_email.py
      args:
        executable: python3
      vars:
        execution_env_csv_file_path: "{{ execution_env_csv_file_path }}"
        gmail_user: "{{ gmail_user }}"
        gmail_pass: "{{ gmail_pass }}"
        subject: "Ansible-report test"
        body: "Ansible AWX report from {{ ansible_facts['hostname'] }}"

- name: Create send_email.py script
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Create Python script to send email
      ansible.builtin.copy:
        dest: /home/automation/send_email.py
        content: |
          import smtplib
          from email.mime.multipart import MIMEMultipart
          from email.mime.text import MIMEText
          from email.mime.base import MIMEBase
          from email import encoders
          import os

          def send_email(user, password, recipient, subject, body, attachment_path):
              # Set up the MIME
              message = MIMEMultipart()
              message['From'] = user
              message['To'] = recipient
              message['Subject'] = subject

              # Attach the body with the msg instance
              message.attach(MIMEText(body, 'plain'))

              # Open the file to be sent
              attachment = open(attachment_path, "rb")

              # Instance of MIMEBase and named as p
              part = MIMEBase('application', 'octet-stream')

              # To change the payload into encoded form
              part.set_payload((attachment).read())

              # Encode into base64
              encoders.encode_base64(part)

              part.add_header('Content-Disposition', "attachment; filename= %s" % os.path.basename(attachment_path))

              # Attach the instance 'part' to instance 'message'
              message.attach(part)

              # Create SMTP session for sending the mail
              server = smtplib.SMTP('smtp.gmail.com', 587)
              server.starttls()
              server.login(user, password)
              text = message.as_string()
              server.sendmail(user, recipient, text)
              server.quit()

          # Variables
          gmail_user = os.environ['gmail_user']
          gmail_pass = os.environ['gmail_pass']
          execution_env_csv_file_path = os.environ['execution_env_csv_file_path']
          subject = os.environ['subject']
          body = os.environ['body']

          # Send email
          send_email(gmail_user, gmail_pass, gmail_user, subject, body, execution_env_csv_file_path)
